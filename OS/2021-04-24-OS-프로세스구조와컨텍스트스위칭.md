## 프로세스와 컨텍스트 스위칭
#### 프로세스 구조
- 프로세스의 구성 형태
    - text(code): 코드
    - data: 변수/초기화된 데이터
    - stack: 임시 데이터(함수 호출, 전역 변수 등)
    - heap: 코드에서 동적으로 만들어지는 데이터

![프로세스](./img/프로세스구조.png)

이 그림을 통해 파이썬 코드가 실행될 때 프로세스는 어떻게 동작하는지를 알아볼 것이다. 우선 코드가 컴파일 되는데 이는 binary 형태인 기계어로 변환되는 것을 의미한다.
먼저 코드에는 컴파일된 소스 코드가 저장된다. 그 후, c=0...변수 선언의 경우에는 '데이터'라는 공간에 특정공간에 넣어준다.
함수가 실행되는 부분인 c = func(1,2)에서 함수가 실행된 후에 return Address값을 스택에 저장하고 그 인자도 스택에 저장한다. 그 후, 다 처리하면 두번째, 첫번쨰 인자 순으로 없애고 Retrun Address를 보고 print(c) 코드로 가서 실행하게 된다.
Heap이라는 공간은 c언어에서는 malloc()으로 처리하는데 이는 동적 메모리 공간을 생성한다. DATA, Code 공간은 정적 공간이고, Stack은 함수를 위한 공간이여서 추가하기 애매한 상황일 때 Heap이라는 동적 공간을 사용한다.

![프로세스c](./img/프로세스구조C.png)

그림을 보면 별도의 선언된 변수가 없기 때문에 data에 아무것도 없다. 주소가 0003h인 부분에서 main이 실행되는데 return address는 0006h...즉, 메인 밖에 존재하는 부분이 stack에 쌓이게 된다. 그 후에 argc, argv 순으로 쌓이게 된다. 그리고 실질적으로 실행되는 return값의 리턴 주소인 0005h가 stack에 쌓이고 data=1, temp = 1 순으로 stack에 쌓인다.
실행이 끝나면 맨 끝부터 없애고 그러다가 return address를 만나면 PC의 값을 0005h로 바꾼 후에 스택에서 return address를 없앤다. 그렇게 메인 함수가 끝나고 argv부터 또 없앤다. 그러다가 return address:0006h가 나오면 PC 값을 0006h로 바꾼 후 스택에서 없애고 끝이 난다.

#### 프로세스와 컴퓨터 구조
- 프로세스
    - text
    - data
    - stack
    - heap
- 컴퓨터 구조
    - PC(Program Counter)
    : 코드를 한 줄 한 줄 가리키는 주소 레지스터
    - SP(Stack Pointer)
    : 함수가 실행될 때, 스택에 최상단 주소를 가리키는 레지스터

![프로세스와컴퓨터구조2](./img/프로세스와컴퓨터구조2.png)

![프로세스와컴퓨터구조3](./img/프로세스와컴퓨터구조3.png)

프로세스만 보는 것과 달리 PC, SP, EBP, EAX가 눈에 띈다는 것을 볼 수 있다. 프로세스를 실행할 때 문제가 생기는 경우, 어떤 함수를 어느 시점에서 실행하다가 문제가 생긴지 알기가 어렵다. 따라서 EBP 레지스터로 함수가 호출된 최상단 SP를 가져오기 떄문에 어느 부분에서 문제가 있었는지 확인이 가능하다. 이것이 EBP를 쓰는 이유이다.
프로그램 실행시, 코드가 프로세스 코드 영역에 올려진다. 코드가 실행되면 PC는 처음부분인 0000h를 가리키게 된다. SP는 스택에 아무것도 없어서 1000h를 가리킨다. c=0은 변수 선언 부분이기 때문에 데이터 영역으로 들어간다. PC에 0001h, 0002h를 넣어도 함수 선언 부분이기 때문에 아무런 반응을 하지 않는다.

![프로세스와컴퓨터구조4](./img/프로세스와컴퓨터구조4.png)

PC가 0003h가 되면, EBP의 값이 stack에 올라가게 된다. 그 후, Return Address:0004h(함수가 끝났을 떄, 돌아갈 리턴 주소)가 stack에 들어간다. 그 밑으로는 함수 인자값 a와 b가 스택에 들어간다.

![프로세스와컴퓨터구조5](./img/프로세스와컴퓨터구조5.png)

인자까지 들어가면 SP는 stack의 끝부분 주소인 0FFCh를 가리키게 된다. a+b를 하면 리턴값은 EAX에 저장이 된다.

![프로세스와컴퓨터구조6](./img/프로세스와컴퓨터구조6.png)

stack의 값들이 다 사라지게 되면 PC는 0004h를 가리키게 된다. 

![프로세스와컴퓨터구조7](./img/프로세스와컴퓨터구조7.png)

그래서 PC가 c=func() 코드를 실행하게 되고 결과로 Data=3이 된다. 이렇게 모든 실행이 끝나면 PC는 마지막 부분의 주소인 0005h를 가리키고 끝이 난다.

#### 프로세스구조와 힙

![프로세스구조와힙](./img/프로세스구조와힙.png)

stack 영역에 return address: 0006h가 들어가게 된다. 그리고 첫부분인 int *data가 stakc에 들어가게 되고 다음부분인 malloc함수는 동적 메모리 공간이므로 Heap으로 들어가게 된다.

![프로세스구조와힙2](./img/프로세스구조와힙2.png)

이때, heap으로 들어가는 것은 값이 아니라 공간이 들어가는 것이기 때문에 그림과 같이 값을 기준으로 봤을 때, heap에 0이 들어가고 stack에서는 data가 0이 들어간 heap 주소 1000h를 가리키게 된다. 그 후에 다음 줄에서 *data에 1이라는 값을 넣어줬기 때문에 heap에 0 대신에 1로 바뀌게 된다.

#### 프로세스구조와 데이터
- Data 영역은 BSS(초기화되지 않은 전역변수)와 Data(초기값이 있는 전역변수)로 분리

![프로세스구조와데이터](./img/프로세스구조와데이터.png)

그림에서 코드를 보게 되면 int global_data1;은 초기값이 없어서 BSS로 들어가게 되고, int global_data2=1;은 초기값이 있기 때문에 Data에 들어가게 된다. 
메인 함수 안에 있는 int *data는 지역변수이기 때문에 stack에 들어가게 된다.

